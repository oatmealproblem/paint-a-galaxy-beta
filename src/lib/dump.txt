const MODE_DRAW = 'draw';
const MODE_ERASE = 'erase';
type BrushMode = typeof MODE_DRAW | typeof MODE_ERASE;

let brush_size = new LocalStorageState('brushSize', 25);
let brush_opacity = new LocalStorageState('brushOpacity', 0.5);
let brush_blur = new LocalStorageState('brushBlur', 0);
let brush_mode = new LocalStorageState<BrushMode>('brushMode', MODE_DRAW);

let number_of_stars = new LocalStorageState('numberOfStars', 600);
let cluster_diffusion = new LocalStorageState('clusterDiffusion', 10);

let connectedness = new LocalStorageState('connectedness', 0.5);
let max_connection_length = new LocalStorageState('maxConnectionLength', 100);
let allow_disconnected = new LocalStorageState('allowDisconnected', false);

let galaxy_name = new LocalStorageState('name', 'Painted Galaxy');
let file_name = $derived(
	galaxy_name.current
		.toLowerCase()
		.replaceAll(' ', '_')
		.replaceAll(/\/\\<>:"\|\?\*/g, ''),
);

function toggle_wormhole(from: [number, number], to: [number, number]) {
	const index = wormholes.current.findIndex(
		(c) =>
			(are_points_equal(c[0], from) && are_points_equal(c[1], to)) ||
			(are_points_equal(c[1], from) && are_points_equal(c[0], to)),
	);
	if (index === -1) {
		// each system can only have 1 wormhole, so remove any wormholes that share an origin or destination
		wormholes.current = wormholes.current.filter(
			(c) =>
				!(
					are_points_equal(c[0], from) ||
					are_points_equal(c[0], to) ||
					are_points_equal(c[1], from) ||
					are_points_equal(c[1], to)
				),
		);
		wormholes.current.push([from, to]);
	} else {
		wormholes.current.splice(index, 1);
	}
}

function toggle_home_star(
	star: [number, number],
	{ preferred }: { preferred: boolean },
) {
	const index = potential_home_stars.current.findIndex(
		(s) => s === star.toString(),
	);
	const preferred_index = preferred_home_stars.current.findIndex(
		(s) => s === star.toString(),
	);
	if (index === -1 && preferred_index === -1) {
		potential_home_stars.current.push(star.toString());
		if (preferred) preferred_home_stars.current.push(star.toString());
	} else if (index >= 0 && preferred_index >= 0) {
		potential_home_stars.current.splice(index, 1);
		preferred_home_stars.current.splice(preferred_index, 1);
	} else if (index >= 0 && preferred_index === -1) {
		if (preferred) {
			preferred_home_stars.current.push(star.toString());
		} else {
			potential_home_stars.current.splice(index, 1);
		}
	}
}

function toggle_hyperlane(from: [number, number], to: [number, number]) {
	const index = connections.current.findIndex(
		(c) =>
			(are_points_equal(c[0], from) && are_points_equal(c[1], to)) ||
			(are_points_equal(c[1], from) && are_points_equal(c[0], to)),
	);
	if (index === -1) {
		connections.current.push([from, to]);
	} else {
		connections.current.splice(index, 1);
	}
}

function toggle_star(point: [number, number]) {
	const index = stars.current.findIndex((star) =>
		are_points_equal(star, point),
	);
	if (index === -1) {
		stars.current.push(point);
	} else {
		stars.current.splice(index, 1);
		connections.current = connections.current.filter(
			(c) => !(are_points_equal(c[0], point) || are_points_equal(c[1], point)),
		);
		wormholes.current = wormholes.current.filter(
			(c) => !(are_points_equal(c[0], point) || are_points_equal(c[1], point)),
		);
	}
}

const onClick = throttle((e) => {
	if (step === Step.STARS) {
		toggle_star([e.offsetX, e.offsetY]);
	} else if (step === Step.HYPERLANES) {
		const star_index = star_delaunay?.find(e.offsetX, e.offsetY);
		if (star_index == null) return;
		if (toggling_hyperlane_from) {
			if (stars.current[star_index] !== toggling_hyperlane_from) {
				toggle_hyperlane(toggling_hyperlane_from, stars.current[star_index]);
			}
			toggling_hyperlane_from = null;
		} else {
			toggling_hyperlane_from = stars.current[star_index];
		}
	} else if (step === Step.WORMHOLES) {
		console.log('wormhole step click');
		const star_index = star_delaunay?.find(e.offsetX, e.offsetY);
		if (star_index == null) return;
		if (toggling_wormhole_from) {
			if (stars.current[star_index] !== toggling_wormhole_from) {
				toggle_wormhole(toggling_wormhole_from, stars.current[star_index]);
			}
			toggling_wormhole_from = null;
		} else {
			toggling_wormhole_from = stars.current[star_index];
		}
	} else if (step === Step.SPAWNS) {
		const star_index = star_delaunay?.find(e.offsetX, e.offsetY);
		if (star_index == null) return;
		toggle_home_star(stars.current[star_index], { preferred: e.shiftKey });
	}
	// some users were experiencing duplicate clicks that instantly toggled on/off; add a small throttle
}, 250);

const onPointerDown = (e) => {
	if (e.button !== 0) return;
	if (step === Step.PAINT) {
		stroke_points = [{ x: e.offsetX, y: e.offsetY }];
	} else if (step === Step.NEBULAS) {
		if (!e.shiftKey) {
			creating_nebula = [e.offsetX, e.offsetY, CUSTOM_NEBULA_MIN_RADIUS];
		}
	}
};

const onPointerUp = (e) => {
	if (step === Step.PAINT) {
		if (stroke_points.length)
			stroke_points.push({ x: e.offsetX, y: e.offsetY });
	} else if (step === Step.NEBULAS) {
		if (creating_nebula) {
			creating_nebula[2] = Math.max(
				CUSTOM_NEBULA_MIN_RADIUS,
				Math.round(
					Math.hypot(
						e.offsetX - creating_nebula[0],
						e.offsetY - creating_nebula[1],
					),
				),
			);
		}
	}
};

const onUpload = async (e) => {
	const input = e.currentTarget;
	const file = input.files?.item(0);
	if (ctx && file) {
		ctx.filter = 'grayscale(1)';
		ctx.drawImage(await createImageBitmap(file), 0, 0, 900, 900);
		convert_grayscale_to_opacity({ clear_low_opacity: true });
		save_canvas();
		canvas?.toBlob(async (blob) => {
			if (blob) {
				initial_bitmap = await createImageBitmap(blob);
				strokes = [];
				undone_strokes = [];
				image_data_stack = [];
				image_data_undo_stack = [];
			}
		});
	}
};

// debounce mod generation
function download_mod() {
	if (!download_link) throw new Error('download_link does not exist');
	const download_url = URL.createObjectURL(
		new Blob(
			[
				generate_stellaris_galaxy(
					galaxy_name.current,
					stars.current,
					connections.current,
					wormholes.current,
					potential_home_stars.current,
					preferred_home_stars.current,
					nebulas.current,
				),
			],
			{ type: 'text/plain' },
		),
	);
	download_link.href = download_url;
	download_link.click();
}
let download_invalid = $derived(
	stars.current.length === 0 || connections.current.length === 0,
);
let download_disabled = $derived(!galaxy_name || download_invalid);
let download_link = $state<HTMLAnchorElement>();

let star_delaunay = $derived(
	step === Step.HYPERLANES || step === Step.WORMHOLES || step === Step.SPAWNS ?
		new Delaunay(stars.current.flat())
	:	null,
);

function randomize_home_systems(
	graph: Graph<
		{ coords: [number, number]; d: number },
		{ distance: number; isMst?: boolean }
	>,
) {

}
